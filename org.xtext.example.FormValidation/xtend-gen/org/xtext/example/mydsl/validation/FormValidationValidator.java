/**
 * generated by Xtext 2.9.1
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import formValidation.AcceptableValuesDate;
import formValidation.AcceptableValuesString;
import formValidation.AttributeRule;
import formValidation.AttributeType;
import formValidation.ClassAttribute;
import formValidation.DatePattern;
import formValidation.EVrsta;
import formValidation.FormValidationPackage;
import formValidation.Length;
import formValidation.MaxDate;
import formValidation.MaxLength;
import formValidation.MinDate;
import formValidation.MinLength;
import formValidation.StringPattern;
import formValidation.ValidationClass;
import formValidation.impl.MinDateImpl;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.xtext.example.mydsl.validation.AbstractFormValidationValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class FormValidationValidator extends AbstractFormValidationValidator {
  public final static String INVALID_NAME = "invalidName";
  
  @Check
  public void checkClassName(final ValidationClass valClass) {
    String _name = valClass.getName();
    char _charAt = _name.charAt(0);
    boolean _isUpperCase = Character.isUpperCase(_charAt);
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Class name should start with a capital", FormValidationPackage.Literals.VALIDATION_CLASS__NAME, FormValidationValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkAttributeName(final ClassAttribute classAttribute) {
    String _name = classAttribute.getName();
    char _charAt = _name.charAt(0);
    boolean _isLowerCase = Character.isLowerCase(_charAt);
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Attribute name should start with a lowercase letter", 
        FormValidationPackage.Literals.CLASS_ATTRIBUTE__NAME, FormValidationValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkStringRule(final ClassAttribute classAttribute) {
    boolean isLength = false;
    boolean isMaxOrMin = false;
    AttributeType _attributetype = classAttribute.getAttributetype();
    EVrsta _vrsta = _attributetype.getVrsta();
    boolean _equals = Objects.equal(_vrsta, EVrsta.STRING);
    if (_equals) {
      EList<AttributeRule> _attributerule = classAttribute.getAttributerule();
      for (final AttributeRule attrRule : _attributerule) {
        if ((attrRule instanceof Length)) {
          isLength = true;
        } else {
          if ((attrRule instanceof MaxLength)) {
            isMaxOrMin = true;
          } else {
            if ((attrRule instanceof MinLength)) {
              isMaxOrMin = true;
            }
          }
        }
      }
      if ((isLength && isMaxOrMin)) {
        this.error("It must not be set length rule at same time as minlength or maxlength. Please chose suitable rule.", 
          FormValidationPackage.Literals.CLASS_ATTRIBUTE__ATTRIBUTERULE);
      }
    }
  }
  
  @Check
  public void checkStringAcceptableValuse(final ClassAttribute classAttribute) {
    int length = (-1);
    int minLength = (-1);
    int maxLength = (-1);
    AttributeType _attributetype = classAttribute.getAttributetype();
    EVrsta _vrsta = _attributetype.getVrsta();
    boolean _equals = Objects.equal(_vrsta, EVrsta.STRING);
    if (_equals) {
      EList<AttributeRule> _attributerule = classAttribute.getAttributerule();
      for (final AttributeRule rule : _attributerule) {
        if ((rule instanceof Length)) {
          int _value = ((Length)rule).getValue();
          length = _value;
        } else {
          if ((rule instanceof MinLength)) {
            int _value_1 = ((MinLength)rule).getValue();
            minLength = _value_1;
          } else {
            if ((rule instanceof MaxLength)) {
              int _value_2 = ((MaxLength)rule).getValue();
              maxLength = _value_2;
            }
          }
        }
      }
    }
    if ((length != (-1))) {
      EList<AttributeRule> _attributerule_1 = classAttribute.getAttributerule();
      for (final AttributeRule rule_1 : _attributerule_1) {
        if ((rule_1 instanceof AcceptableValuesString)) {
          final AcceptableValuesString accValues = ((AcceptableValuesString) rule_1);
          EList<String> _values = accValues.getValues();
          for (final String value : _values) {
            int _length = value.length();
            boolean _notEquals = (_length != length);
            if (_notEquals) {
              this.error("Values from acceptable values must be specific length", rule_1, FormValidationPackage.Literals.ACCEPTABLE_VALUES_STRING__VALUES);
            }
          }
        }
      }
    } else {
      if (((minLength != (-1)) && (maxLength != (-1)))) {
        EList<AttributeRule> _attributerule_2 = classAttribute.getAttributerule();
        for (final AttributeRule rule_2 : _attributerule_2) {
          if ((rule_2 instanceof AcceptableValuesString)) {
            final AcceptableValuesString accValues_1 = ((AcceptableValuesString) rule_2);
            EList<String> _values_1 = accValues_1.getValues();
            for (final String value_1 : _values_1) {
              boolean _or = false;
              int _length_1 = value_1.length();
              boolean _greaterThan = (_length_1 > maxLength);
              if (_greaterThan) {
                _or = true;
              } else {
                int _length_2 = value_1.length();
                boolean _lessThan = (_length_2 < minLength);
                _or = _lessThan;
              }
              if (_or) {
                this.error("Length of value from acceptable values must be between specific min length and max length", rule_2, FormValidationPackage.Literals.ACCEPTABLE_VALUES_STRING__VALUES);
              }
            }
          }
        }
      } else {
        if ((minLength != (-1))) {
          EList<AttributeRule> _attributerule_3 = classAttribute.getAttributerule();
          for (final AttributeRule rule_3 : _attributerule_3) {
            if ((rule_3 instanceof AcceptableValuesString)) {
              final AcceptableValuesString accValues_2 = ((AcceptableValuesString) rule_3);
              EList<String> _values_2 = accValues_2.getValues();
              for (final String value_2 : _values_2) {
                int _length_3 = value_2.length();
                boolean _lessThan_1 = (_length_3 < minLength);
                if (_lessThan_1) {
                  this.error("Length of value from acceptable values must be longer.", rule_3, FormValidationPackage.Literals.ACCEPTABLE_VALUES_STRING__VALUES);
                }
              }
            }
          }
        } else {
          if ((maxLength != (-1))) {
            EList<AttributeRule> _attributerule_4 = classAttribute.getAttributerule();
            for (final AttributeRule rule_4 : _attributerule_4) {
              if ((rule_4 instanceof AcceptableValuesString)) {
                final AcceptableValuesString accValues_3 = ((AcceptableValuesString) rule_4);
                EList<String> _values_3 = accValues_3.getValues();
                for (final String value_3 : _values_3) {
                  int _length_4 = value_3.length();
                  boolean _lessThan_2 = (_length_4 < minLength);
                  if (_lessThan_2) {
                    this.error("Length of values from acceptable values must be shorter", accValues_3, FormValidationPackage.Literals.ACCEPTABLE_VALUES_STRING__VALUES);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkStringPattern(final ClassAttribute attribute) {
    boolean _and = false;
    boolean _and_1 = false;
    boolean _isStrngType = this.isStrngType(attribute);
    if (!_isStrngType) {
      _and_1 = false;
    } else {
      boolean _containsStringPattern = this.containsStringPattern(attribute);
      _and_1 = _containsStringPattern;
    }
    if (!_and_1) {
      _and = false;
    } else {
      boolean _containsAcceptableValues = this.containsAcceptableValues(attribute);
      _and = _containsAcceptableValues;
    }
    if (_and) {
      final String stringPattern = this.getStringPattern(attribute);
      EList<AttributeRule> _attributerule = attribute.getAttributerule();
      for (final AttributeRule rule : _attributerule) {
        if ((rule instanceof AcceptableValuesString)) {
          final AcceptableValuesString stringRule = ((AcceptableValuesString) rule);
          EList<String> _values = stringRule.getValues();
          for (final String value : _values) {
            boolean _matches = value.matches(stringPattern);
            boolean _not = (!_matches);
            if (_not) {
              this.error("Acceptable values don\'t match pattern", rule, FormValidationPackage.Literals.ACCEPTABLE_VALUES_STRING__VALUES);
            } else {
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkDateFormat(final ClassAttribute attribute) {
    boolean _isDateType = this.isDateType(attribute);
    if (_isDateType) {
      String datePattern = "dd/MM/yyyy";
      boolean _isDatePatternDefined = this.isDatePatternDefined(attribute);
      if (_isDatePatternDefined) {
        String _datePatern = this.getDatePatern(attribute);
        datePattern = _datePatern;
      }
      boolean _isMaxDateDefined = this.isMaxDateDefined(attribute);
      if (_isMaxDateDefined) {
        String maxDateValue = this.getMaxDate(attribute);
        AttributeRule maxDateRule = this.getMaxDateRule(attribute);
        boolean _isFormatOk = this.isFormatOk(datePattern, maxDateValue);
        boolean _not = (!_isFormatOk);
        if (_not) {
          this.error("It is not good date format", maxDateRule, FormValidationPackage.Literals.MAX_DATE__VALUE);
        }
      }
      boolean _isMinDateDefined = this.isMinDateDefined(attribute);
      if (_isMinDateDefined) {
        String minDateValue = this.getMinDate(attribute);
        AttributeRule minDateRule = this.getMinDateRule(attribute);
        boolean _isFormatOk_1 = this.isFormatOk(datePattern, minDateValue);
        boolean _not_1 = (!_isFormatOk_1);
        if (_not_1) {
          this.error("It is not good date forma", minDateRule, FormValidationPackage.Literals.MIN_DATE__VALUE);
        }
      }
      boolean _and = false;
      boolean _isMinDateDefined_1 = this.isMinDateDefined(attribute);
      if (!_isMinDateDefined_1) {
        _and = false;
      } else {
        boolean _isMaxDateDefined_1 = this.isMaxDateDefined(attribute);
        _and = _isMaxDateDefined_1;
      }
      if (_and) {
        String minDateValue_1 = this.getMinDate(attribute);
        String maxDateValue_1 = this.getMaxDate(attribute);
        boolean _compareMinAndMaxDate = this.compareMinAndMaxDate(minDateValue_1, maxDateValue_1, datePattern);
        boolean _not_2 = (!_compareMinAndMaxDate);
        if (_not_2) {
          this.error("Min date is after max date", FormValidationPackage.Literals.CLASS_ATTRIBUTE__ATTRIBUTERULE);
        }
      }
      boolean _isDateAcceptableValues = this.isDateAcceptableValues(attribute);
      if (_isDateAcceptableValues) {
        AttributeRule _dateAcceptableValues = this.getDateAcceptableValues(attribute);
        AcceptableValuesDate acceptableValuesDate = ((AcceptableValuesDate) _dateAcceptableValues);
        EList<String> _values = acceptableValuesDate.getValues();
        for (final String value : _values) {
          boolean _isFormatOk_2 = this.isFormatOk(datePattern, value);
          boolean _not_3 = (!_isFormatOk_2);
          if (_not_3) {
            this.error("Value is not appropriate format", acceptableValuesDate, FormValidationPackage.Literals.ACCEPTABLE_VALUES_DATE__VALUES);
          }
        }
      }
    }
  }
  
  public boolean isFormatOk(final String pattern, final String value) {
    boolean flag = true;
    SimpleDateFormat sdf = new SimpleDateFormat(pattern);
    try {
      Date date = sdf.parse(value);
      String _format = sdf.format(date);
      boolean _equals = value.equals(_format);
      boolean _not = (!_equals);
      if (_not) {
        flag = false;
      }
    } catch (final Throwable _t) {
      if (_t instanceof ParseException) {
        final ParseException ex = (ParseException)_t;
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return flag;
  }
  
  public boolean isDateType(final ClassAttribute attribute) {
    boolean flag = false;
    AttributeType _attributetype = attribute.getAttributetype();
    EVrsta _vrsta = _attributetype.getVrsta();
    boolean _equals = Objects.equal(_vrsta, EVrsta.DATE);
    if (_equals) {
      flag = true;
    }
    return flag;
  }
  
  public String getMaxDate(final ClassAttribute attribute) {
    String maxDateValue = "WRONG";
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof MaxDate)) {
        MaxDate maxDate = ((MaxDate) rule);
        String _value = maxDate.getValue();
        maxDateValue = _value;
      }
    }
    return maxDateValue;
  }
  
  public AttributeRule getMaxDateRule(final ClassAttribute attribute) {
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    AttributeRule maxDate = _attributerule.get(0);
    EList<AttributeRule> _attributerule_1 = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule_1) {
      if ((rule instanceof MaxDate)) {
        maxDate = ((MaxDate) rule);
      }
    }
    return maxDate;
  }
  
  public AttributeRule getMinDateRule(final ClassAttribute attribute) {
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    AttributeRule minDateRule = _attributerule.get(0);
    EList<AttributeRule> _attributerule_1 = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule_1) {
      if ((rule instanceof MinDate)) {
        minDateRule = ((MinDateImpl) rule);
      }
    }
    return minDateRule;
  }
  
  public String getMinDate(final ClassAttribute attribute) {
    String minDateValue = "WRONG";
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof MinDate)) {
        MinDateImpl minDate = ((MinDateImpl) rule);
        String _value = minDate.getValue();
        minDateValue = _value;
        return minDateValue;
      }
    }
    return minDateValue;
  }
  
  public String getDatePatern(final ClassAttribute attribute) {
    String patternValue = "WRONG";
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof DatePattern)) {
        DatePattern pattern = ((DatePattern) rule);
        String _value = pattern.getValue();
        patternValue = _value;
        return patternValue;
      }
    }
    return patternValue;
  }
  
  public boolean isMaxDateDefined(final ClassAttribute attribute) {
    boolean isDefined = false;
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof MaxDate)) {
        isDefined = true;
      }
    }
    return isDefined;
  }
  
  public boolean isMinDateDefined(final ClassAttribute attribute) {
    boolean isDefined = false;
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof MinDate)) {
        isDefined = true;
      }
    }
    return isDefined;
  }
  
  public boolean isDatePatternDefined(final ClassAttribute attribute) {
    boolean isDefined = false;
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof DatePattern)) {
        isDefined = true;
      }
    }
    return isDefined;
  }
  
  public boolean isStrngType(final ClassAttribute attr) {
    AttributeType _attributetype = attr.getAttributetype();
    EVrsta _vrsta = _attributetype.getVrsta();
    boolean _equals = Objects.equal(_vrsta, EVrsta.STRING);
    if (_equals) {
      return true;
    } else {
      return false;
    }
  }
  
  public boolean containsStringPattern(final ClassAttribute attr) {
    EList<AttributeRule> _attributerule = attr.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof StringPattern)) {
        return true;
      }
    }
    return false;
  }
  
  public boolean containsAcceptableValues(final ClassAttribute attr) {
    EList<AttributeRule> _attributerule = attr.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof AcceptableValuesString)) {
        return true;
      }
    }
    return false;
  }
  
  public String getStringPattern(final ClassAttribute attr) {
    EList<AttributeRule> _attributerule = attr.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof StringPattern)) {
        final StringPattern strPatt = ((StringPattern) rule);
        return strPatt.getValue();
      }
    }
    return "WRONG";
  }
  
  public boolean compareMinAndMaxDate(final String minDate, final String maxDate, final String pattern) {
    try {
      boolean flag = true;
      SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
      Date dateMin = sdf.parse(minDate);
      Date dateMax = sdf.parse(maxDate);
      int _compareTo = dateMax.compareTo(dateMin);
      boolean _lessEqualsThan = (_compareTo <= 0);
      if (_lessEqualsThan) {
        flag = false;
      }
      return flag;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public boolean isDateAcceptableValues(final ClassAttribute attribute) {
    boolean datePattern = false;
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule) {
      if ((rule instanceof AcceptableValuesDate)) {
        datePattern = true;
      }
    }
    return datePattern;
  }
  
  public AttributeRule getDateAcceptableValues(final ClassAttribute attribute) {
    EList<AttributeRule> _attributerule = attribute.getAttributerule();
    AttributeRule datePatternRule = _attributerule.get(0);
    EList<AttributeRule> _attributerule_1 = attribute.getAttributerule();
    for (final AttributeRule rule : _attributerule_1) {
      if ((rule instanceof AcceptableValuesDate)) {
        datePatternRule = ((AcceptableValuesDate) rule);
      }
    }
    return datePatternRule;
  }
}
